<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[丽江]]></title>
    <url>%2F2018%2F01%2F25%2F%E4%B8%BD%E6%B1%9F%2F</url>
    <content type="text"><![CDATA[香格里拉过后，和海狗来到了丽江来过丽江几次，每次都很喜欢。网上有很多关于丽江的负面的新闻，但幸运的是每次去都觉得挺好的哈哈 这次和海狗去的不是大研古镇而是束河古镇，很少，也比较幽静些 就住在这种客栈里，有一条大大的金毛（居然没有图）这里的很多客栈都养大狗狗，每天路上走着就能看到很多，超幸福的 内部装修也很古色古香 他住的房间叫海子，我的叫锅庄哈哈哈哈可能是淡季去的房间也很便宜，印象中是不到一百一间吧~旺季去怕就很贵了 美丽的小院子 到一个喝茶的小店晒晒太阳可以说是懒洋洋的幸福了~ 束河的酒吧没有大研那么多，但也还是有的，酒吧街就很热闹 晚上的束河很寂静 莫名害怕哈哈哈 我记得我们还去了白马古镇，居然没有照片！总的来说香格里拉和丽江我都很喜欢！愉快的记忆~]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>游纪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[香格里拉]]></title>
    <url>%2F2018%2F01%2F25%2F%E9%A6%99%E6%A0%BC%E9%87%8C%E6%8B%89%2F</url>
    <content type="text"><![CDATA[2016年初，忘记起因为何与海狗和他来自福建的大学同学一起前往香格里拉找格桑玩耍。在云南这么多年，最喜欢的地方除了昆明之外香格里拉可以算其一。因为离西藏很近，也是藏区，冬天去更有一种萧瑟之感。 香格里拉的飞机场建筑风格就很藏了，这里的天仿佛更近了 松赞林寺，可以感受到自己的渺小 带我们旅行的姐姐的服饰应该是很传统的藏服了吧？ 朝圣 普达措的雪景。听说夏天都是鲜花，一定要夏天再来一次！ 在一个什么草原上骑马，天好蓝！冬天去的好处就是人少，景区什么的也稍微便宜些。 晚上出去，可以照到很多很多的星星~~~(≧∇≦)ﾉ]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>游纪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半山腰]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%8D%8A%E5%B1%B1%E8%85%B0%2F</url>
    <content type="text"><![CDATA[周二终于解锁半山腰，可可以说是很高逼格的云南菜了，小小记录一下 环境很美丽啦主要是小花花好看（和xj摆拍感觉还是有点意境的） 上菜！ 芒果拔丝乳扇，芒果好评！乳扇一直都一般般不过新意点赞！汤是小瓜炖火腿，可以算是比较传统的云南菜色了~汤很浓郁适合冬天 花生汤西洋菜和什么后羊腿吧，羊肉炖的好烂好烂，搭上蘸水简直是太喜欢了！ 最喜欢的还是这个，牛肝菌汤拌饭！雾草现在想想都口水流，把把菌汤浇在饭上冬天吃这一碗感觉没白活哈哈哈哈可能是我太饿了 这个牛肝菌冰淇淋是来前一直听附中群里学长宣传的别致菜色。牛肝菌加上蜂蜜的味道果然很黑暗哈，不过多吃几口还是挺不错的。 总结：好次但好贵，三个人吃了468，折后428（被大佬校友罩了瞬间超幸福）人多点来吃应该更好，可以多尝些菜~这里的菜基本是普通云南菜的改良升级创新版，不一样的体验哈哈。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>食纪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习NumPy]]></title>
    <url>%2F2018%2F01%2F23%2F%E5%AD%A6%E4%B9%A0NumPy%2F</url>
    <content type="text"><![CDATA[一开始使用的是Atom text editor+ Python3.6然后在cmd中运行的方式书写，但发现用IPthon更好，可以边写边输出。 学习NumPyCreaeting ndarraysThe easiest way to create an array is to use the array function 1234import numpy as npdata1 = [6,7.5,8,0,1]arr1 = np.array(data1)arr1 array([ 6. , 7.5, 8. , 0. , 1. ]) 123data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]arr2 = np.array(data2)arr2 array([[1, 2, 3, 4], [5, 6, 7, 8]]) 1arr2.ndim 2 1arr2.shape (2, 4) 用empty制造两个随机矩阵（可能为0）It’s not safe to assume that np.empty will return an array of all zeros. In many cases, it will return uninitialized garbage values 1np.empty((2, 3, 2)) array([[[ 0., 0.], [ 0., 0.], [ 0., 0.]], [[ 0., 0.], [ 0., 0.], [ 0., 0.]]]) DataTypes for ndarraysThe data type or dtype is a special object containing the information the ndarray needs to interpret a chunk of memory as a particular type of data:Dtypes are part of what make NumPy so powerful and flexible. In most cases they map directly onto an underlying machine representation, which makes it easy to read and write binary streams of data to disk and also to connect to code written in a low-level language like C or Fortran. The numerical dtypes are named the same way: a type name, like float or int, followed by a number indicating the number of bits per element. A standard double-precision floating point value (what’s used under the hood in Python’s float object) takes up 8 bytes or 64 bits. Thus, this type is known in NumPy as float64. 以下是用dtype初始定义ndarray的字段类型，以及用astype重新转换字段类型。 12arr1 = np.array([1, 2, 3], dtype=np.float64)arr1. dtype dtype(&apos;float64&apos;) 12arr1 = arr1.astype(np.int32)arr1. dtype dtype(&apos;int32&apos;) Calling astype always creates a new array (a copy of the data), even if the new dtype is the same as the old dtype. Array 的使用格式相同的两个arrays可以直接进行运算，which is called vectorization 向量化 Basic Indexing and Slicingone-dimensional array根据 list 的方式操作，但有点不同： An important first distinction from lists is that array slices are views on the original array. This means that the data is not copied, and any modifications to the view will be reflected in the source array: 具体不理解去书上看下，意思就是用改变新的变量定义的array，原始的array也会改变，不做copying benefits big volumn 的 data processing。要copy的话需要make a copy manually two-dimensional arrayIn a two-dimensional array, the elements at each index are no longer scalars but rather one-dimensional arrays: 12arr2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])arr2[2] array([7, 8, 9]) Thus, individual elements can be accessed recursively. But that is a bit too much work, so you can pass a comma-separated list of indices to select individual elements. So these are equivalent: 1arr2[0][2] 3 1arr2[0,2] 3 muti的去书上看下例子，本质相似 12arr2[:2, 1:]#右边不包括 array([[2, 3], [5, 6]]) When slicing like this, you always obtain array views of the same number of dimensions. By mixing integer indexes and slices, you get lower dimensional slices for an illustration. Note that a colon by itself means to take the entire axis, so you can slice only higher dimensional axes by doing: 且给选择区域赋值，就是全部赋值 1arr2[:,:1] array([[1], [4], [7]]) Boolean array自动匹配，must be of the same length as the axis it’s indexing 123names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])data = np.random.rand(7, 4)data[names == 'Bob'] array([[ 0.9557655 , 0.22905675, 0.50431088, 0.60829347], [ 0.75815624, 0.50279706, 0.70783685, 0.79516102]]) 1names != 'Bob' array([False, True, True, False, True, True, True], dtype=bool) 1data [~(names == 'Bob')] array([[ 0.42484035, 0.39654515, 0.661522 , 0.13543556], [ 0.88815595, 0.39119882, 0.31034169, 0.81300137], [ 0.23840864, 0.29161556, 0.5933545 , 0.82938969], [ 0.65710103, 0.69543904, 0.11611022, 0.52827679], [ 0.19459546, 0.04671212, 0.67820323, 0.22418191]]) 12mask = (names == 'Bob') | (names == 'Will')mask array([ True, False, True, True, True, False, False], dtype=bool) Selecting data from an array by boolean indexing always creates a copy of the data, even if the returned array is unchanged. 12data[data &lt; 0] = 0data array([[ 0.9557655 , 0.22905675, 0.50431088, 0.60829347], [ 0.42484035, 0.39654515, 0.661522 , 0.13543556], [ 0.88815595, 0.39119882, 0.31034169, 0.81300137], [ 0.75815624, 0.50279706, 0.70783685, 0.79516102], [ 0.23840864, 0.29161556, 0.5933545 , 0.82938969], [ 0.65710103, 0.69543904, 0.11611022, 0.52827679], [ 0.19459546, 0.04671212, 0.67820323, 0.22418191]]) Fancy indexing123for i in range(7): data[i] = idata array([[ 0., 0., 0., 0.], [ 1., 1., 1., 1.], [ 2., 2., 2., 2.], [ 3., 3., 3., 3.], [ 4., 4., 4., 4.], [ 5., 5., 5., 5.], [ 6., 6., 6., 6.]]) 1data[[-3, -5, -7]] array([[ 4., 4., 4., 4.], [ 2., 2., 2., 2.], [ 0., 0., 0., 0.]]) 12data = np.arange(32).reshape((8, 4))data array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]]) 1data[[1, 5, 7, 2], [0, 3, 1, 2]] array([ 4, 23, 29, 10]) !! reshape 之后详细介绍 Take a moment to understand what just happened: the elements (1, 0), (5, 3), (7, 1), and (2, 2) were selected. The behavior of fancy indexing in this case is a bit different from what some users might have expected (myself included), which is the rectangular region formed by selecting a subset of the matrix’s rows and columns. Here is one way to get that: 1data[[1, 5, 7, 2]][:,[0, 3, 1, 2]] array([[ 4, 7, 5, 6], [20, 23, 21, 22], [28, 31, 29, 30], [ 8, 11, 9, 10]]) Another way is to use the np.ix_ function, which converts two 1D integer arrays to an indexer that selects the square region: 1data[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])] array([[ 4, 7, 5, 6], [20, 23, 21, 22], [28, 31, 29, 30], [ 8, 11, 9, 10]]) Transposing Arrays and Swapping Axes1data.T array([[ 0, 4, 8, 12, 16, 20, 24, 28], [ 1, 5, 9, 13, 17, 21, 25, 29], [ 2, 6, 10, 14, 18, 22, 26, 30], [ 3, 7, 11, 15, 19, 23, 27, 31]]) 1np.dot(data.T, data) array([[2240, 2352, 2464, 2576], [2352, 2472, 2592, 2712], [2464, 2592, 2720, 2848], [2576, 2712, 2848, 2984]]) 更多的转置再看看，完全忘记。上面那个好像是算一个product什么的 Universal Functions就是可以运算矩阵的一些函数 1234points = np.arange(-5, 5, 0.01) # 1000 equally spaced pointsxs, ys = np.meshgrid(points, points)z = np.sqrt(xs ** 2 + ys ** 2)z array([[ 7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985, 7.06400028], [ 7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815, 7.05692568], [ 7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354, 7.04985815], ..., [ 7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603, 7.04279774], [ 7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354, 7.04985815], [ 7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815, 7.05692568]]) Expressing Conditional Logic as Array OperationsThe numpy.where function is a vectorized version of the ternary expression x if condi tion else y. Suppose we had a boolean array and two arrays of values:(后两项并不是必须为array) 12345xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])cond = np.array([True, False, True, True, False])result = np.where(cond, xarr, yarr)result array([ 1.1, 2.2, 1.3, 1.4, 2.5]) Mathematical and Statistical MethodsA set of mathematical functions which compute statistics about an entire array or about the data along an axis are accessible as array methods. Aggregations (often called reductions) like sum, mean, and standard deviation std can either be used by calling the array instance method or using the top level NumPy functio Sortmethod np.sort returns a sorted copy of an array instead of modifying the array in place 12data1 = np.random.rand(4,3)data1 array([[ 0.12799622, 0.83893776, 0.57784444], [ 0.09005918, 0.73211886, 0.73407077], [ 0.28310393, 0.73966797, 0.88664488], [ 0.38199501, 0.73302471, 0.17547308]]) 12data1[0].sort()data1 array([[ 0.12799622, 0.57784444, 0.83893776], [ 0.09005918, 0.73211886, 0.73407077], [ 0.28310393, 0.73966797, 0.88664488], [ 0.38199501, 0.73302471, 0.17547308]]) 12data1.sort()data1 array([[ 0.12799622, 0.57784444, 0.83893776], [ 0.09005918, 0.73211886, 0.73407077], [ 0.28310393, 0.73966797, 0.88664488], [ 0.17547308, 0.38199501, 0.73302471]]) 看不下去了以后用到再查吧 出门去吃半山腰啦哇哈哈哈哈哈哈 2018.1.23 明天把剩下的表做完就可以看pandas了吼吼。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>learning notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Example]]></title>
    <url>%2F2018%2F01%2F19%2FPython-Study-Note-1%2F</url>
    <content type="text"><![CDATA[学习笔记来自《Python for Data Analysis》 An example of using Python standard library &amp; pandas123456789101112import jsonfrom collections import defaultdict#count the appearance of time zonedef get_counts2(sequence): counts = defaultdict(int) # values will initialize to 0 for x in sequence: counts[x] += 1return countspath = &apos;ch02/usagov_bitly_data2012-03-16-1331923249.txt&apos;records = [json.loads(line) for line in open(path)] List Comprehension: a concise way of applying an operation (like json.loads) to a collection of strings or other objects. Counting Time Zones with Python standard library1234567In [19]: records[0]Out[19]: u&apos;America/New_YorkIn [31]: counts = get_counts(time_zones)In [32]: counts[&apos;America/New_York&apos;]Out[32]: 1251In [33]: len(time_zones)Out[33]: 3440 1234def top_counts(count_dict, n=10): value_key_pairs = [(count, tz) for tz, count in count_dict.items()] value_key_pairs.sort() return value_key_pairs[-n:] 12In [35]: top_counts(counts)Out[35]: [(33, u&apos;America/Sao_Paulo&apos;), (35, u&apos;Europe/Madrid&apos;), (36, u&apos;Pacific/Honolulu&apos;), (37, u&apos;Asia/Tokyo&apos;), (74, u&apos;Europe/London&apos;), (191, u&apos;America/Denver&apos;), (382, u&apos;America/Los_Angeles&apos;), (400, u&apos;America/Chicago&apos;), (521, u&apos;&apos;), (1251, u&apos;America/New_York&apos;)] If you search the Python standard library, you may find the collections.Counter class, which makes this task a lot easier: 12 from collections import Counter counts = Counter(time_zones)counts.most_common(10) Counting Time Zones with Pandas123from pandas import DataFrame, Seriesimport pandas as pdframe = DataFrame(records) The output shown for the frame is the summary view, shown for large DataFrame objects. The Series object returned by frame[‘tz’] has a method value_counts that gives us what we’re looking for: 12In [294]: tz_counts = frame[&apos;tz&apos;].value_counts()In [295]: tz_counts[:10] You can do a bit of munging to fill in a substitute value for unknown and missing time zone data in the records. The fillna function can replace missing (NA) values and unknown (empty strings) values can be replaced by boolean array indexing: 123In [296]: clean_tz = frame[&apos;tz&apos;].fillna(&apos;Missing&apos;)In [297]: clean_tz[clean_tz == &apos;&apos;] = &apos;Unknown&apos;In [298]: tz_counts = clean_tz.value_counts() Making a horizontal bar plot can be accomplished using the plot method on the counts objects: 1In [301]: tz_counts[:10].plot(kind=&apos;barh&apos;, rot=0)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>learning notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Blog]]></title>
    <url>%2F2018%2F01%2F19%2FFirst-Blog%2F</url>
    <content type="text"><![CDATA[第一篇博客突发奇想建这个博客，起因是…这几天有幸和陈肖哥哥交流，被他的个人网站上的简洁风深深吸引。偶然看到《快速创建自己博客》，也想要自己试试创建自己的网站，于是便在今天（2018.1.19）一边做着朝阳布置的任务，一边照着大神们总结的用 hexo+github 创建blog的帖子们操作，没想到最后真的建起来了这个网站！激动之余也希望能在这里记录下未来一年的生活（买的域名持续一年）和成长轨迹。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>random</tag>
      </tags>
  </entry>
</search>
